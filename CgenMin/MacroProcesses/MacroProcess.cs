using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using CodeGenerator.ProblemHandler;
using static System.Net.Mime.MediaTypeNames;

namespace CgenMin.MacroProcesses
{

    class MacroVar
    {
        ///name of var to be replaced in file
        public string MacroName;
        ///value to replace
        public string VariableValue;
    }


    abstract class MacroProcess
    {
        public string EvironmentDirectory { get; private set; }

        private static bool FirstCall = false;
        private static List<string> SectionComments  =new List<string>();
        private static Stack<string> SectionNameStack = new Stack<string>();


        public MacroProcess()
        {
            probhandler = new ProblemHandle();
            EvironmentDirectory = "";
        }

        ///-------------------------------------------------
        public void Init(string environDir) 
        { 
            EvironmentDirectory = environDir; 
        }
        public abstract void RunProcess();


        ///-------------------------------------------------
        public string GrabFileContents(string fileFromRelativePath )
        {
            string fullpath =Path.Combine(this.EvironmentDirectory, fileFromRelativePath);
            //check if this file exists, if not, throw problem.
            if (File.Exists(fullpath) == false)
            {
                probhandler.ThereisAProblem($"file {fullpath} did not exist. when attempting to grab it.");
                System.Environment.Exit(1);
            }
            return File.ReadAllText(fullpath); 
            
        }



        ///-------------------------------------------------
        public void WriteFileContents(string contentsToWrite, string toFileFromRelativePath, string extensionOfFile)
        {
            string commentSyntax = @"//";
            extensionOfFile = extensionOfFile.Replace(@".",@"");
            if (extensionOfFile == "cpp" ||
            extensionOfFile == "hpp" ||
            extensionOfFile == "c" ||
            extensionOfFile == "h" ||
            extensionOfFile == "cs" )
            {
                commentSyntax = @"//";
            }else if(extensionOfFile == "cmake" ||
            extensionOfFile == "py" ||
            extensionOfFile == "bash" || 
            extensionOfFile == "sh" ||
            extensionOfFile == "bat")
            {
                commentSyntax = @"#"; 
            }

            contentsToWrite = 
            commentSyntax + "############################################### \n" + 
            commentSyntax + "this is an autogenerated file using cgen's macro2 command. Dont modify this file here unless it is in user sections \n" + 
            commentSyntax + "###############################################" + "\n\n" + contentsToWrite ;
            if (Path.HasExtension(toFileFromRelativePath))
            {
                if (Path.GetExtension(toFileFromRelativePath) != extensionOfFile  )
                {
                    probhandler.ThereisAProblem($"the file you gave {toFileFromRelativePath} has the wrong extension. should be {extensionOfFile}");
 
                }
            }
            else
            { 
                toFileFromRelativePath = Path.ChangeExtension(toFileFromRelativePath, extensionOfFile);
            }


            List<string> contentsToWriteSplit = Regex.Split(contentsToWrite, "\r\n|\r|\n").ToList();

            var ttt = new {CommentIndex = 0,CommentLinNum = 0,CommentContentToInsert = ""};
            var markingList = new[] {ttt}.ToList();markingList.Clear();

            for (int i = 0; i < contentsToWriteSplit.Count; i++)
            {
                //replace comment markings with the associated comments. But only do this on a new line before the comment marking
                Regex anySectionsRegex = new Regex(@"<<\*(?<CommentIndex>\d*)\*>>");
                var matchesr = anySectionsRegex.Matches(contentsToWriteSplit[i])
                .Cast<Match>()
                .Select(s => new {CommentIndex =  Int32.Parse(s.Groups["CommentIndex"].Value),
                                  CommentLinNum = i,
                                  CommentContentToInsert = SectionComments[Int32.Parse(s.Groups["CommentIndex"].Value)] })
                .ToList();  

                //remove the comment markings
                foreach (var item in matchesr)
                {
                    contentsToWriteSplit[i] = contentsToWriteSplit[i].Replace($@"<<*{item.CommentIndex}*>>",$"");    
                }
 
                markingList.AddRange(matchesr); 
            }

            markingList = markingList.OrderByDescending(m => m.CommentLinNum).ToList();
            foreach (var mlist in markingList)
            {
                //go through the markings found from before and replace the comment contents on the line before
                contentsToWriteSplit.Insert(mlist.CommentLinNum, commentSyntax + mlist.CommentContentToInsert);
            }
 

            string fullpath =Path.Combine(this.EvironmentDirectory, toFileFromRelativePath);
            
             File.WriteAllText(fullpath,string.Join("\n",contentsToWriteSplit));  
        }





    ///-------------------------------------------------
    ///This function will get the contents of the input file provided and replace the macrovariables passed in.
    ///Any places marked with @$something$@ will be considered a subMacroProcess that will run within the same class.
    public string GenerateFileOut(string fromInputFile, params MacroVar[] macVar)
    {
        bool isTopLevel = FirstCall == false ? true : false; 
        FirstCall = true;

        //if the file extention is wrong, throw a problem. if there is no extention, give it one. 
        if (Path.HasExtension(fromInputFile))
        {
            if (Path.GetExtension(fromInputFile) != "cgenMM" || Path.GetExtension(fromInputFile) != ".cgenMM")
            {
                probhandler.ThereisAProblem($"the file you gave {fromInputFile} has the wrong extension. should be .cgenMM");
                System.Environment.Exit(1);
            }
        }
        else
        {
            fromInputFile = Path.ChangeExtension(fromInputFile, "cgenMM");
        }


        string fileContents = this.GrabFileContents(fromInputFile);

        //go through and replace macro variables.
        foreach (var mVar in macVar)
        {
            fileContents = fileContents.Replace($"@{mVar.MacroName}@",$"{mVar.VariableValue}");
        }

        Regex anyMacrosleftRegex = new Regex(@"@(?<MacroName>\w*)@");
        var matches = anyMacrosleftRegex.Matches(fileContents);
         Match mc = anyMacrosleftRegex.Match(fileContents);
        if(mc.Success)
        { 
            probhandler.ThereisAProblem($"there was still a macro left that you did not provide a macrovar for. For input file {fromInputFile}. \n with macro name: {mc.Groups["MacroName"].Value}");
            System.Environment.Exit(1);
        }  

        //now I need to grab all processRun vars, reflect into the function here. If I find that function, run it.
        Regex anySectionsRegex = new Regex(@"@\$(?<SectionName>\w*)\$@");
        var matchesr = anySectionsRegex.Matches(fileContents)
        .Cast<Match>()
        .Select(s => new {SectionName = s.Groups["SectionName"].Value})
        .ToList();  


        List<MethodInfo> methodsForSectionsToCall = new List<MethodInfo>();
        foreach (var m in matchesr)
        {
            //go through every section captured and reflect into the function if it exists.

            var methodsHere = this.GetType().GetMethods();
            var functiontToCallHere = methodsHere
            .Where( method => method.Name == m.SectionName)
            .FirstOrDefault();

            if (functiontToCallHere == null)
            {
                probhandler.ThereisAProblem($"you  did not provide a function for section named {m.SectionName}  for file {fromInputFile}");
            } 

            methodsForSectionsToCall.Add(functiontToCallHere); 
        }

        //go through all methodsForSectionsToCall and invoke them.
        string sectionName = "";
        for (int i = 0; i < methodsForSectionsToCall.Count; i++)
        {  
            SectionNameStack.Push(matchesr[i].SectionName); 
            string sectionContentsToFill = (string)methodsForSectionsToCall[i].Invoke(this,null); 
            AddCommentMark(ref sectionContentsToFill, $"Macro2: {matchesr[i].SectionName}");
            sectionName = SectionNameStack.Pop(); 
  
            //Now that I have the contents of the section, I can replace it 
            fileContents = fileContents.Replace($"@${matchesr[i].SectionName}$@",$"{sectionContentsToFill}");  

            
        } 

 
        //turn off FirstCall indicating that top level call of this recursive funcion is done
        if (isTopLevel == true)
        {
            isTopLevel = false;
            FirstCall = false; 
            sectionName = "TopLevel";
            //SectionComments.Clear();
        } 
        else
        {
            sectionName = SectionNameStack.Peek();
        }

        //place a comment marker to be removed later at the end of the top level vall to this function. 
        AddCommentMark(ref fileContents, $"Macro2 - {fromInputFile}::{sectionName}");
        //  fileContents = $@"<<*{SectionComments.Count}*>>"+fileContents;
        //  SectionComments.Add(fromInputFile + "::" + sectionName); 
 


        return fileContents;
    }
 



    ///-------------------------------------------------
    private void AddCommentMark(ref string fileContents, string commentValue)
    {
        fileContents = $@"<<*{SectionComments.Count}*>>"+fileContents;
        SectionComments.Add(commentValue); 
    }

    //private -----------------------------------------------
    protected ProblemHandle probhandler; 


    }



}
