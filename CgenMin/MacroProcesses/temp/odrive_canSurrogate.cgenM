##Macro1 
 ##LoopIncrement1 
 ##ToFile C:\Users\SyncthingServiceAcct\QR_Sync\cablecam\rosqt\include\cablecam_rqt\odrive_canSurrogate.h 
//############################################### 
//this is an autogenerated file using cgen's macro2 command. Dont modify this file here unless it is in user sections 
//###############################################

#pragma once

//place all headers you need here.
##UserCode_header

#include "odrive_can/srv/axis_state.hpp" 




#include "QR_Core.h"





namespace cablecam_rqt {
//using namespace odrive_can::msg;
using namespace odrive_can::srv;
//using namespace cablecam_cp;
 

//this gets code generated 100% from the previous  cpp object! there is nothing for the user to do here. all public functions will be code generated over to here.
//This is the surrogate object.
 
typedef Ticket<std::shared_ptr<odrive_can::srv::AxisState::Response>> AxisStateTicket_t; 

 
 
//This class is the surrogate class
class odrive_canSurrogate 
{
public:

 
    

	##UserCode_public

    //This class should not be instantiated by the user. instead the odrive_canInitialized_Callback will handle
	//instantiations of this class.
odrive_canSurrogate(std::string id)
    {
		##UserCode_constr1
	
        

		//you need a spinning node. make sure that node is not being used for the same service you are trying to call. currently TheDataAccessManager is being
		//used for clients.   
		
        auto nodeToUse =  TheDataAccessManagerNode;//rclcpp::Node::make_shared(id+"odrive_canSurrogate");;

        //instances of surrogates can be created at any point of the application life cycle! THink aboiut the case
        //here where cablecam holds a list of gameobjects. These gameobjects are AO that can be created at any time.


        //scratch the bottom!!! ----------------------------------------------------
        //we are assuming that the instance for this surrogate is created already. we need to grab the data for this surrogate
        //before moving on. The reason we need to wait to grab it is because we are assuming that this application relies on this
        //instance being created already. What this means though is that instances of AO CANNOT be instantiated in midst of the application
        //running. For example within function calls might have  odrive_can* w = new odrive_can();
 

		//=====================================
		//AOFUNCTION_CLIENTS
		//=====================================
		clientAxisState = nodeToUse->create_client<odrive_can::srv::AxisState>(id + "/request_axis_state"); 

		
		 
		##UserCode_constr2
SurrogateDatasyncCallbackGroup = TheDataAccessManagerNode->create_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);		

		//DATASYNC_DEFINE
		

    }
 
 public:
 
 	//=====================================
	//AOFUNCTION_IMPS
	//===================================== 
	    //the non-async version will just call the async version but will immediately wait for the ticket.
    std::shared_ptr<odrive_can::srv::AxisState::Response> AxisState(uint32_t axis_requested_state) 
    {
        auto ticket = AxisState_async(axis_requested_state);
        return ticket->AwaitRequestUntilFinished();
    }




    TicketFuture_RosService_NONQR<std::shared_future<
                                rclcpp::Client<odrive_can::srv::AxisState>::SharedResponse>,
                            std::shared_ptr<odrive_can::srv::AxisState::Response>,
                            odrive_can::srv::AxisState>* TicketFor_AxisState;


    AxisStateTicket_t* AxisState_async(uint32_t axis_requested_state) 
    {
        //in this surrogate, I need to prepare the data for transmission over the network.
        //First I need to package the data into the data interface type for this service function.
        //If one of the arguments for the function is an "AOSurrogate" type, a string Id will be used
        //as a replacement for it. The example for this interface type will be

        //        WorldMoveObject.srv
        //        odrive_can::msg::uint32_t result
        //        ---
        //        std_msgs::msg::String surrogate
        //        odrive_can::msg::Move move

		auto request = std::make_shared<odrive_can::srv::AxisState::Request>();  
		 //whenever the arguments is a surrogate, it will get the id instead of passing the actual object
        request->axis_requested_state = axis_requested_state;

 



        TicketFor_AxisState= new TicketFuture_RosService_NONQR<std::shared_future<
                                                           rclcpp::Client<odrive_can::srv::AxisState>::SharedResponse>,
                                                           std::shared_ptr<odrive_can::srv::AxisState::Response>,
                                                           odrive_can::srv::AxisState>();
        auto result =
            clientAxisState->async_send_request(request, TicketFor_AxisState->CallbackToServiceVar); 

        TicketFor_AxisState->SetNewFuture(result.future);

        //create the ticket the user can use to await this request.
        TicketFor_AxisState->MutexForTicket.lock();
        return (AxisStateTicket_t*)TicketFor_AxisState;
    }



 
  
 
	//UPDATE_CALLBACK
	 
	 
	 rclcpp::CallbackGroup::SharedPtr SurrogateDatasyncCallbackGroup;
	 //DATASYNC_DECL
	 

	
	//=====================================
	//DATASYNC_IMPS
	//===================================== 
	//

private:

	##UserCode_priv

	//AOFUNCTION_CLIENT_DECLARES
	rclcpp::Client<odrive_can::srv::AxisState>::SharedPtr clientAxisState;

	 

};


//SURROGATE_INIT
 



}










 

