##Macro1 
 ##LoopIncrement1 
 ##ToFile C:\Users\SyncthingServiceAcct\QR_Sync\cablecam\rosqt\include\cablecam_rqt\CablecamobjectSurrogate.h 
//############################################### 
//this is an autogenerated file using cgen's macro2 command. Dont modify this file here unless it is in user sections 
//###############################################

#pragma once

//place all headers you need here.
##UserCode_header

#include "cablecam_i/msg/cablecamobject_data.hpp" 






#include "cablecam_cp/CablecamobjectBase.h" 



namespace cablecam_rqt {
using namespace cablecam_i::msg;
using namespace cablecam_i::srv;
using namespace cablecam_cp;
 

//this gets code generated 100% from the previous  cpp object! there is nothing for the user to do here. all public functions will be code generated over to here.
//This is the surrogate object.
 

 
 
//This class is the surrogate class
class CablecamobjectSurrogate : public  CablecamobjectBase 
{
public:

 
    friend void CablecamobjectInitialized_Callback(const cablecam_i::msg::CablecamobjectData msg);

	##UserCode_public

    //This class should not be instantiated by the user. instead the CablecamobjectInitialized_Callback will handle
	//instantiations of this class.
CablecamobjectSurrogate(std::string id): CablecamobjectBase(id)
    {
		##UserCode_constr1
	
        _isReal = false;

		//you need a spinning node. make sure that node is not being used for the same service you are trying to call. currently TheDataAccessManager is being
		//used for clients.   
		
        auto nodeToUse =  TheDataAccessManagerNode;//rclcpp::Node::make_shared(id+"CablecamobjectSurrogate");;

        //instances of surrogates can be created at any point of the application life cycle! THink aboiut the case
        //here where cablecam holds a list of gameobjects. These gameobjects are AO that can be created at any time.


        //scratch the bottom!!! ----------------------------------------------------
        //we are assuming that the instance for this surrogate is created already. we need to grab the data for this surrogate
        //before moving on. The reason we need to wait to grab it is because we are assuming that this application relies on this
        //instance being created already. What this means though is that instances of AO CANNOT be instantiated in midst of the application
        //running. For example within function calls might have  Cablecamobject* w = new Cablecamobject();
 

		//=====================================
		//AOFUNCTION_CLIENTS
		//=====================================
		
		
		 
		##UserCode_constr2
SurrogateDatasyncCallbackGroup = TheDataAccessManagerNode->create_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);		

		//DATASYNC_DEFINE
		

    }
 
 public:
 
 	//=====================================
	//AOFUNCTION_IMPS
	//===================================== 
	
 
  
 
	//UPDATE_CALLBACK
	     void UpdateObjCallback(const cablecam_i::msg::CablecamobjectData* msg)
    {
        data = *msg;
    }

    void _UpdateObjCallback(const cablecam_i::msg::CablecamobjectData::SharedPtr msg)
    {
        UpdateObjCallback(msg.get());
        //        data = *);
    }
	 
	 rclcpp::CallbackGroup::SharedPtr SurrogateDatasyncCallbackGroup;
	 //DATASYNC_DECL
	 

	
	//=====================================
	//DATASYNC_IMPS
	//===================================== 
	//

private:

	##UserCode_priv

	//AOFUNCTION_CLIENT_DECLARES
	
	 

};


//SURROGATE_INIT
 

//This object will subscribe to an initialization event that all REAL AO objects publish after they are created.
//For example, for this case, a CablecamobjectAO will publish an InitializedEvent triggered via a one shot timer when the AO spins.
//Then all modules that have a surrogate of this type will get that event and sync CablecamobjectDataAccess data with it.


class CablecamobjectInit
{
public:
    rclcpp::Subscription<cablecam_i::msg::CablecamobjectData>::SharedPtr subscriptionInitialized;



    void InitializeSurrogates()
    {
#ifdef AllSurrogates
        auto nodeToUse = TheNodeForAllSurrogates;

#else
        auto nodeToUse = TheDataAccessManagerNode;

#endif

        subscriptionInitialized = nodeToUse->create_subscription<cablecam_i::msg::CablecamobjectData>
                                  ("/CablecamobjectInitialized", 10, std::bind(&CablecamobjectInit::CablecamobjectInitialized_Callback,this, _1));


        /*    subscriptionInitialized = TheDataAccessManagerNode->create_subscription<cablecam_i::msg::CablecamobjectData>
                ("/CablecamobjectInitialized", 10, &CablecamobjectInitialized_Callback);*///std::bind(CablecamobjectInitialized_Callback,_1));//std::bind(&Cablecamobject::CablecamobjectInitialized_Callback, this,_1));
    }

private:

    void CablecamobjectInitialized_Callback(const cablecam_i::msg::CablecamobjectData::SharedPtr msg)
    {
        QR_Print("Surrogate created for AO: %s", msg->id.c_str());
        //if this object exists already, just update the data, if it does not exist, create the object
        CablecamobjectSurrogate* o = (CablecamobjectSurrogate*)CablecamobjectSurrogate::GetObjectFromPool(msg->id);
        if (o == nullptr)
        {
            //first create an instance of the surrogate
            CablecamobjectSurrogate* sur = new CablecamobjectSurrogate(msg->id);
            sur->_UpdateObjCallback(msg);
            //and that's it actually, the object adds itself to the surrogate object pool.

        }
        else
        {
            o->_UpdateObjCallback(msg);

        }

        //maybe notify this AO that the AO in question has been created?

    }

};



}










 

