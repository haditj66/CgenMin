##Macro1 
 ##LoopIncrement1 
 ##ToFile /home/hadi/QR_Sync/world2/rosqt/include/world2_rqt/TestSimpleSurrogate.h 
//############################################### 
//this is an autogenerated file using cgen's macro2 command. Dont modify this file here unless it is in user sections 
//###############################################

#pragma once

//place all headers you need here.
##UserCode_header



#include "QR_Core.h"





namespace world2_rqt {
//using namespace world2_i::msg;
using namespace world2_i::srv;
//using namespace world2_cp;
 

//this gets code generated 100% from the previous  cpp object! there is nothing for the user to do here. all public functions will be code generated over to here.
//This is the surrogate object.
 
typedef Ticket<world2_i::srv::AddTwoNumbers_Response::_result_type> AddTwoNumbersTicket_t; 
typedef Ticket<world2_i::srv::GiveName_Response::_result_type> GiveNameTicket_t; 

 
 
//This class is the surrogate class
class TestSimpleSurrogate 
{
public:

 
    

	##UserCode_public

    //This class should not be instantiated by the user. instead the TestSimpleInitialized_Callback will handle
	//instantiations of this class.
TestSimpleSurrogate(std::string id)
    {
		##UserCode_constr1
	
        

		//you need a spinning node. make sure that node is not being used for the same service you are trying to call. currently TheDataAccessManager is being
		//used for clients.   
		
        auto nodeToUse =  TheDataAccessManagerNode;//rclcpp::Node::make_shared(id+"TestSimpleSurrogate");;

        //instances of surrogates can be created at any point of the application life cycle! THink aboiut the case
        //here where world2 holds a list of gameobjects. These gameobjects are AO that can be created at any time.


        //scratch the bottom!!! ----------------------------------------------------
        //we are assuming that the instance for this surrogate is created already. we need to grab the data for this surrogate
        //before moving on. The reason we need to wait to grab it is because we are assuming that this application relies on this
        //instance being created already. What this means though is that instances of AO CANNOT be instantiated in midst of the application
        //running. For example within function calls might have  TestSimple* w = new TestSimple();
 

		//=====================================
		//AOFUNCTION_CLIENTS
		//=====================================
		clientAddTwoNumbers = nodeToUse->create_client<world2_i::srv::AddTwoNumbers>(id + "/AddTwoNumbers"); 
clientGiveName = nodeToUse->create_client<world2_i::srv::GiveName>(id + "/GiveName"); 

		
		 
		##UserCode_constr2
SurrogateDatasyncCallbackGroup = TheDataAccessManagerNode->create_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);		

		//DATASYNC_DEFINE
		

    }
 
 public:
 
 	//=====================================
	//AOFUNCTION_IMPS
	//===================================== 
	    //the non-async version will just call the async version but will immediately wait for the ticket.
    int32_t AddTwoNumbers(int32_t a,int32_t b) 
    {
        auto ticket = AddTwoNumbers_async(a, b);
        return ticket->AwaitRequestUntilFinished();
    }




    TicketFuture_RosService<std::shared_future<
                                rclcpp::Client<world2_i::srv::AddTwoNumbers>::SharedResponse>,
                            world2_i::srv::AddTwoNumbers_Response::_result_type,
                            world2_i::srv::AddTwoNumbers>* TicketFor_AddTwoNumbers;


    AddTwoNumbersTicket_t* AddTwoNumbers_async(int32_t a,int32_t b) 
    {
        //in this surrogate, I need to prepare the data for transmission over the network.
        //First I need to package the data into the data interface type for this service function.
        //If one of the arguments for the function is an "AOSurrogate" type, a string Id will be used
        //as a replacement for it. The example for this interface type will be

        //        WorldMoveObject.srv
        //        world2_i::msg::int32_t result
        //        ---
        //        std_msgs::msg::String surrogate
        //        world2_i::msg::Move move

		auto request = std::make_shared<world2_i::srv::AddTwoNumbers::Request>();  
		 //whenever the arguments is a surrogate, it will get the id instead of passing the actual object
        request->a = a;

request->b = b;

 



        TicketFor_AddTwoNumbers= new TicketFuture_RosService<std::shared_future<
                                                           rclcpp::Client<world2_i::srv::AddTwoNumbers>::SharedResponse>,
                                                           world2_i::srv::AddTwoNumbers_Response::_result_type,
                                                           world2_i::srv::AddTwoNumbers>();
        auto result =
            clientAddTwoNumbers->async_send_request(request, TicketFor_AddTwoNumbers->CallbackToServiceVar); 

        TicketFor_AddTwoNumbers->SetNewFuture(result.future);

        //create the ticket the user can use to await this request.
        TicketFor_AddTwoNumbers->MutexForTicket.lock();
        return (AddTwoNumbersTicket_t*)TicketFor_AddTwoNumbers;
    }


    //the non-async version will just call the async version but will immediately wait for the ticket.
    std::string GiveName() 
    {
        auto ticket = GiveName_async();
        return ticket->AwaitRequestUntilFinished();
    }




    TicketFuture_RosService<std::shared_future<
                                rclcpp::Client<world2_i::srv::GiveName>::SharedResponse>,
                            world2_i::srv::GiveName_Response::_result_type,
                            world2_i::srv::GiveName>* TicketFor_GiveName;


    GiveNameTicket_t* GiveName_async() 
    {
        //in this surrogate, I need to prepare the data for transmission over the network.
        //First I need to package the data into the data interface type for this service function.
        //If one of the arguments for the function is an "AOSurrogate" type, a string Id will be used
        //as a replacement for it. The example for this interface type will be

        //        WorldMoveObject.srv
        //        world2_i::msg::std::string result
        //        ---
        //        std_msgs::msg::String surrogate
        //        world2_i::msg::Move move

		auto request = std::make_shared<world2_i::srv::GiveName::Request>();  
		 //whenever the arguments is a surrogate, it will get the id instead of passing the actual object
        
 



        TicketFor_GiveName= new TicketFuture_RosService<std::shared_future<
                                                           rclcpp::Client<world2_i::srv::GiveName>::SharedResponse>,
                                                           world2_i::srv::GiveName_Response::_result_type,
                                                           world2_i::srv::GiveName>();
        auto result =
            clientGiveName->async_send_request(request, TicketFor_GiveName->CallbackToServiceVar); 

        TicketFor_GiveName->SetNewFuture(result.future);

        //create the ticket the user can use to await this request.
        TicketFor_GiveName->MutexForTicket.lock();
        return (GiveNameTicket_t*)TicketFor_GiveName;
    }



 
  
 
	//UPDATE_CALLBACK
	 
	 
	 rclcpp::CallbackGroup::SharedPtr SurrogateDatasyncCallbackGroup;
	 //DATASYNC_DECL
	 

	
	//=====================================
	//DATASYNC_IMPS
	//===================================== 
	//

private:

	##UserCode_priv

	//AOFUNCTION_CLIENT_DECLARES
	rclcpp::Client<world2_i::srv::AddTwoNumbers>::SharedPtr clientAddTwoNumbers;
rclcpp::Client<world2_i::srv::GiveName>::SharedPtr clientGiveName;

	 

};


//SURROGATE_INIT
 



}










 

