##Macro1 
 ##LoopIncrement1 
 ##ToFile C:\Users\SyncthingServiceAcct\QR_Sync\world2\rosqt\include\world2_rqt\GameobjectNodeAO.h 
//############################################### 
//this is an autogenerated file using cgen's macro2 command. Dont modify this file here unless it is in user sections 
//###############################################

#pragma once
 
#include "Config.hpp"

#include "world2_cp/Gameobject.h"
#include "QR_Core.h" 
  
#include "rclcpp/rclcpp.hpp"
#include "std_msgs/msg/string.hpp"

#include <chrono>
#include <memory>
#include <functional>
#include <string>

#include "qr_core/srv/sync_int32.hpp"
#include "qr_core/msg/void_int32_changed.hpp"

//**************************************************************************************************************
//This ABSTRACT class is 100% code generated! users should derive from this class to create their own AO.
//this is the class that will have asychronous calls taken into account. This is what will call the internal
//object.
//This base AO class will be full code generated. However, the class that inherits from this base class will be user created. That class will have
//extra things like timers or subscriptions or etc.


namespace world2_rqt {
	using std::placeholders::_1;
	using std::placeholders::_2;
	
using namespace world2_i::msg;
using namespace world2_i::srv;
using namespace world2_cp;

class GameobjectNodeAO// : public rclcpp::Node
{
public:



    //std::shared_ptr<WorldNode> fForNode;
    rclcpp::Node*  ForNode;
    world2_cp::Gameobject* cppobj;

	//this event is published when the node for the real AO is created. All surrogate nodes will be
	// notified by this event. This
    rclcpp::Publisher<world2_i::msg::GameobjectData>::SharedPtr publisherInitialized;

	//WNFUNCTION_SERVICES
	    rclcpp::Service<world2_i::srv::SpawnObject>::SharedPtr serviceSpawnObject;
    
 
 
	
	//PROPERTYEVTS_DECLARED
	rclcpp::Service<qr_core::srv::SyncInt32>::SharedPtr servicesetposx;
rclcpp::Service<qr_core::srv::SyncInt32>::SharedPtr servicesetposy;


 
	//PROPERTYEVTS_CHANGED_DECLARE
	rclcpp::Publisher<qr_core::msg::VoidInt32Changed>::SharedPtr publisherposxChanged;
rclcpp::Publisher<qr_core::msg::VoidInt32Changed>::SharedPtr publisherposyChanged;


	//rclcpp::Publisher<qr_core::msg::VoidInt64Changed>::SharedPtr publisherposxChanged;
    //rclcpp::Publisher<qr_core::msg::VoidInt64Changed>::SharedPtr publisherposyChanged;



    //MyNode();
    virtual ~GameobjectNodeAO ()
    {
        rclcpp::shutdown();
    }


rclcpp::CallbackGroup::SharedPtr client_cb_group_;



    void Init(world2_cp::Gameobject* obj)//, rclcpp::executors::MultiThreadedExecutor* exec)
    {
//          fForNode = QR_Core::CreateNode<world2_rqt::WorldNode>(exec, obj->Getid());

//         ForNode = (rclcpp::Node *)fForNode.get();

        this->cppobj = obj;
        std::string n = ForNode->get_name();
        cppobj->Setid(n);

        static const rmw_qos_profile_t rmw_qos_profile_services_default_MINE = {
          RMW_QOS_POLICY_HISTORY_KEEP_LAST,
          1000,
          RMW_QOS_POLICY_RELIABILITY_RELIABLE,
          RMW_QOS_POLICY_DURABILITY_VOLATILE,
          RMW_QOS_DEADLINE_DEFAULT,
          RMW_QOS_LIFESPAN_DEFAULT,
          RMW_QOS_POLICY_LIVELINESS_SYSTEM_DEFAULT,
          RMW_QOS_LIVELINESS_LEASE_DURATION_DEFAULT,
          false};

        client_cb_group_ = ForNode->create_callback_group(
            rclcpp::CallbackGroupType::MutuallyExclusive);
			
			
		//WNFUNCTION_SERVICES_DEFINES	
		         serviceSpawnObject =
            ForNode->create_service<world2_i::srv::SpawnObject>(
            cppobj->Getid() + "/SpawnObject",
            std::bind(&GameobjectNodeAO::SpawnObject, this, _1,_2) 
            ,rmw_qos_profile_services_default_MINE, client_cb_group_); 
				  
			 
    
 




        // I need a publisher to the initialized event. This event will need to be
        // pulished in the initialize function that must be called after this
        // constructor everytime.
        publisherInitialized = ForNode->create_publisher<world2_i::msg::GameobjectData>(
            "/GameobjectInitialized", 100);

        publisherInitialized->publish(cppobj->GetObjectData());
		
		//PROPERTYEVTS_DECLARED
		//since this deals with data access modifying, This will be managed by the DataAccessManagerNode
		servicesetposx =  TheDataAccessManagerNode->create_service<qr_core::srv::SyncInt32>(cppobj->Getid() + "/setposx", std::bind(&GameobjectNodeAO::SetposxCallback, this, _1, _2));
servicesetposy =  TheDataAccessManagerNode->create_service<qr_core::srv::SyncInt32>(cppobj->Getid() + "/setposy", std::bind(&GameobjectNodeAO::SetposyCallback, this, _1, _2));


		
 
		
		//PROPERTYEVTS_CHANGED_DEFINE
		publisherposxChanged = TheDataAccessManagerNode->create_publisher<qr_core::msg::VoidInt32Changed>(obj->Getid() + "/"+ "posx" + "DataChanged",100);
publisherposyChanged = TheDataAccessManagerNode->create_publisher<qr_core::msg::VoidInt32Changed>(obj->Getid() + "/"+ "posy" + "DataChanged",100);


		
		isInitialized = true;
    }

 
 
	//PROPERTYEVTS_SET_CALLBACKS
	    void SetposxCallback(const std::shared_ptr<qr_core::srv::SyncInt32::Request>  request,
                            std::shared_ptr<qr_core::srv::SyncInt32::Response> response )
    {
        this->cppobj->Setposx(request->arg1);

        //publish posx has changed to all surrogates
        auto message = qr_core::msg::VoidInt32Changed();
        message.data = request->arg1;
		message.id1 = request->id1;
        message.id2 = request->id2;
        publisherposxChanged->publish(message);

        //response->result = request->arg1;
        //RCLCPP_INFO(ForNode->get_logger(), "posx has been changed to: %d", request->arg1);
    }
    void SetposyCallback(const std::shared_ptr<qr_core::srv::SyncInt32::Request>  request,
                            std::shared_ptr<qr_core::srv::SyncInt32::Response> response )
    {
        this->cppobj->Setposy(request->arg1);

        //publish posy has changed to all surrogates
        auto message = qr_core::msg::VoidInt32Changed();
        message.data = request->arg1;
		message.id1 = request->id1;
        message.id2 = request->id2;
        publisherposyChanged->publish(message);

        //response->result = request->arg1;
        //RCLCPP_INFO(ForNode->get_logger(), "posy has been changed to: %d", request->arg1);
    }



	
 
	//WNFUNCTIONS_IMPL
	    void SpawnObject(const std::shared_ptr<world2_i::srv::SpawnObject::Request>  request,
                            std::shared_ptr<world2_i::srv::SpawnObject::Response> response )
    {

        //get the AO this arg is suppose to be for. Remember that this object may or may not be a surrogate.
		
		
		##UserCode_SpawnObject1 

        //response->result = 
		this->cppobj->SpawnObject();
		
		##UserCode_SpawnObject2 
    }
		  


  

protected:

	bool isInitialized;

};
}




