##Macro1 
 ##LoopIncrement1 
 ##ToFile /home/hadi/QR_Sync/world2/rosqt/include/world2_rqt/WorldNodeAO.h 
//############################################### 
//this is an autogenerated file using cgen's macro2 command. Dont modify this file here unless it is in user sections 
//###############################################

#pragma once
 
#include "Config.hpp"

#include "world2_cp/World.h"
#include "QR_Core.h" 
  
#include "rclcpp/rclcpp.hpp"
#include "std_msgs/msg/string.hpp"

#include <chrono>
#include <memory>
#include <functional>
#include <string>



//**************************************************************************************************************
//This ABSTRACT class is 100% code generated! users should derive from this class to create their own AO.
//this is the class that will have asychronous calls taken into account. This is what will call the internal
//object.
//This base AO class will be full code generated. However, the class that inherits from this base class will be user created. That class will have
//extra things like timers or subscriptions or etc.


namespace world2_rqt {
	using std::placeholders::_1;
	using std::placeholders::_2;
	
using namespace world2_i::msg;
using namespace world2_i::srv;
using namespace world2_cp;

class WorldNodeAO// : public rclcpp::Node
{
public:



    //std::shared_ptr<WorldNode> fForNode;
    rclcpp::Node*  ForNode;
    world2_cp::World* cppobj;

	//this event is published when the node for the real AO is created. All surrogate nodes will be
	// notified by this event. This
    rclcpp::Publisher<world2_i::msg::WorldData>::SharedPtr publisherInitialized;

	//WNFUNCTION_SERVICES
	    rclcpp::Service<world2_i::srv::MoveObject>::SharedPtr serviceMoveObject;
    
 
    rclcpp::Service<world2_i::srv::AddObjectToWorld>::SharedPtr serviceAddObjectToWorld;
    
 
 
	
	//PROPERTYEVTS_DECLARED
	

 
	//PROPERTYEVTS_CHANGED_DECLARE
	

	//rclcpp::Publisher<qr_core::msg::VoidInt64Changed>::SharedPtr publisherposxChanged;
    //rclcpp::Publisher<qr_core::msg::VoidInt64Changed>::SharedPtr publisherposyChanged;



    //MyNode();
    virtual ~WorldNodeAO ()
    {
        rclcpp::shutdown();
    }


rclcpp::CallbackGroup::SharedPtr client_cb_group_;



    void Init(world2_cp::World* obj)//, rclcpp::executors::MultiThreadedExecutor* exec)
    {
//          fForNode = QR_Core::CreateNode<world2_rqt::WorldNode>(exec, obj->Getid());

//         ForNode = (rclcpp::Node *)fForNode.get();

        this->cppobj = obj;
        std::string n = ForNode->get_name();
        cppobj->Setid(n);

        static const rmw_qos_profile_t rmw_qos_profile_services_default_MINE = {
          RMW_QOS_POLICY_HISTORY_KEEP_LAST,
          1000,
          RMW_QOS_POLICY_RELIABILITY_RELIABLE,
          RMW_QOS_POLICY_DURABILITY_VOLATILE,
          RMW_QOS_DEADLINE_DEFAULT,
          RMW_QOS_LIFESPAN_DEFAULT,
          RMW_QOS_POLICY_LIVELINESS_SYSTEM_DEFAULT,
          RMW_QOS_LIVELINESS_LEASE_DURATION_DEFAULT,
          false};

        client_cb_group_ = ForNode->create_callback_group(
            rclcpp::CallbackGroupType::MutuallyExclusive);
			
			
		//WNFUNCTION_SERVICES_DEFINES	
		         serviceMoveObject =
            ForNode->create_service<world2_i::srv::MoveObject>(
            cppobj->Getid() + "/MoveObject",
            std::bind(&WorldNodeAO::MoveObject, this, _1,_2) 
            ,rmw_qos_profile_services_default_MINE, client_cb_group_); 
				  
			 
    
 
         serviceAddObjectToWorld =
            ForNode->create_service<world2_i::srv::AddObjectToWorld>(
            cppobj->Getid() + "/AddObjectToWorld",
            std::bind(&WorldNodeAO::AddObjectToWorld, this, _1,_2) 
            ,rmw_qos_profile_services_default_MINE, client_cb_group_); 
				  
			 
    
 




        // I need a publisher to the initialized event. This event will need to be
        // pulished in the initialize function that must be called after this
        // constructor everytime.
        publisherInitialized = ForNode->create_publisher<world2_i::msg::WorldData>(
            "/WorldInitialized", 100);

        publisherInitialized->publish(cppobj->GetObjectData());
		
		//PROPERTYEVTS_DECLARED
		//since this deals with data access modifying, This will be managed by the DataAccessManagerNode
		

		
 
		
		//PROPERTYEVTS_CHANGED_DEFINE
		

		
		isInitialized = true;
    }

 
 
	//PROPERTYEVTS_SET_CALLBACKS
	


	
 
	//WNFUNCTIONS_IMPL
	    void MoveObject(const std::shared_ptr<world2_i::srv::MoveObject::Request>  request,
                            std::shared_ptr<world2_i::srv::MoveObject::Response> response )
    {

        //get the AO this arg is suppose to be for. Remember that this object may or may not be a surrogate.
		GameobjectBase* g0 = GameobjectBase::GetObjectFromPool(request->id);

		
		##UserCode_MoveObject1 

        response->result = 
		this->cppobj->MoveObject(g0,request->move);
		
		##UserCode_MoveObject2 
    }
		  
    void AddObjectToWorld(const std::shared_ptr<world2_i::srv::AddObjectToWorld::Request>  request,
                            std::shared_ptr<world2_i::srv::AddObjectToWorld::Response> response )
    {

        //get the AO this arg is suppose to be for. Remember that this object may or may not be a surrogate.
		GameobjectBase* g0 = GameobjectBase::GetObjectFromPool(request->id);

		
		##UserCode_AddObjectToWorld1 

        response->result = 
		this->cppobj->AddObjectToWorld(g0,request->posy,request->posx);
		
		##UserCode_AddObjectToWorld2 
    }
		  


  

protected:

	bool isInitialized;

};
}




