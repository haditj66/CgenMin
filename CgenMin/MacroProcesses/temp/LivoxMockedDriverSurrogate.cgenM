##Macro1 
 ##LoopIncrement1 
 ##ToFile /home/hadi/QR_Sync/livoxmock/rosqt/include/livoxmock_rqt/LivoxMockedDriverSurrogate.h 
//############################################### 
//this is an autogenerated file using cgen's macro2 command. Dont modify this file here unless it is in user sections 
//###############################################

#pragma once

//place all headers you need here.
##UserCode_header

#include "livoxmock_i/srv/filter_point_cloud.hpp" 




#include "QR_Core.h"





namespace livoxmock_rqt {
//using namespace livoxmock_i::msg;
using namespace livoxmock_i::srv;
//using namespace livoxmock_cp;
 

//this gets code generated 100% from the previous  cpp object! there is nothing for the user to do here. all public functions will be code generated over to here.
//This is the surrogate object.
 
typedef Ticket<livoxmock_i::srv::FilterPointCloud_Response::_result_type> FilterPointCloudTicket_t; 

 
 
//This class is the surrogate class
class LivoxMockedDriverSurrogate 
{
public:

 
    

	##UserCode_public

    //This class should not be instantiated by the user. instead the LivoxMockedDriverInitialized_Callback will handle
	//instantiations of this class.
LivoxMockedDriverSurrogate(std::string id)
    {
		##UserCode_constr1
	
        

		//you need a spinning node. make sure that node is not being used for the same service you are trying to call. currently TheDataAccessManager is being
		//used for clients.   
		
        auto nodeToUse =  TheDataAccessManagerNode;//rclcpp::Node::make_shared(id+"LivoxMockedDriverSurrogate");;

        //instances of surrogates can be created at any point of the application life cycle! THink aboiut the case
        //here where livoxmock holds a list of gameobjects. These gameobjects are AO that can be created at any time.


        //scratch the bottom!!! ----------------------------------------------------
        //we are assuming that the instance for this surrogate is created already. we need to grab the data for this surrogate
        //before moving on. The reason we need to wait to grab it is because we are assuming that this application relies on this
        //instance being created already. What this means though is that instances of AO CANNOT be instantiated in midst of the application
        //running. For example within function calls might have  LivoxMockedDriver* w = new LivoxMockedDriver();
 

		//=====================================
		//AOFUNCTION_CLIENTS
		//=====================================
		clientFilterPointCloud = nodeToUse->create_client<livoxmock_i::srv::FilterPointCloud>(id + "/FilterPointCloud"); 

		
		 
		##UserCode_constr2
SurrogateDatasyncCallbackGroup = TheDataAccessManagerNode->create_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);		

		//DATASYNC_DEFINE
		

    }
 
 public:
 
 	//=====================================
	//AOFUNCTION_IMPS
	//===================================== 
	    //the non-async version will just call the async version but will immediately wait for the ticket.
    livoxmock_i::msg::DataFilteredOut FilterPointCloud(int32_t num_filtered) 
    {
        auto ticket = FilterPointCloud_async(num_filtered);
        return ticket->AwaitRequestUntilFinished();
    }




    TicketFuture_RosService<std::shared_future<
                                rclcpp::Client<livoxmock_i::srv::FilterPointCloud>::SharedResponse>,
                            livoxmock_i::srv::FilterPointCloud_Response::_result_type,
                            livoxmock_i::srv::FilterPointCloud>* TicketFor_FilterPointCloud;


    FilterPointCloudTicket_t* FilterPointCloud_async(int32_t num_filtered) 
    {
        //in this surrogate, I need to prepare the data for transmission over the network.
        //First I need to package the data into the data interface type for this service function.
        //If one of the arguments for the function is an "AOSurrogate" type, a string Id will be used
        //as a replacement for it. The example for this interface type will be

        //        WorldMoveObject.srv
        //        livoxmock_i::msg::livoxmock_i::msg::DataFilteredOut result
        //        ---
        //        std_msgs::msg::String surrogate
        //        livoxmock_i::msg::Move move

		auto request = std::make_shared<livoxmock_i::srv::FilterPointCloud::Request>();  
		 //whenever the arguments is a surrogate, it will get the id instead of passing the actual object
        request->num_filtered = num_filtered;

 



        TicketFor_FilterPointCloud= new TicketFuture_RosService<std::shared_future<
                                                           rclcpp::Client<livoxmock_i::srv::FilterPointCloud>::SharedResponse>,
                                                           livoxmock_i::srv::FilterPointCloud_Response::_result_type,
                                                           livoxmock_i::srv::FilterPointCloud>();
        auto result =
            clientFilterPointCloud->async_send_request(request, TicketFor_FilterPointCloud->CallbackToServiceVar); 

        TicketFor_FilterPointCloud->SetNewFuture(result.future);

        //create the ticket the user can use to await this request.
        TicketFor_FilterPointCloud->MutexForTicket.lock();
        return (FilterPointCloudTicket_t*)TicketFor_FilterPointCloud;
    }



 
  
 
	//UPDATE_CALLBACK
	 
	 
	 rclcpp::CallbackGroup::SharedPtr SurrogateDatasyncCallbackGroup;
	 //DATASYNC_DECL
	 

	
	//=====================================
	//DATASYNC_IMPS
	//===================================== 
	//

private:

	##UserCode_priv

	//AOFUNCTION_CLIENT_DECLARES
	rclcpp::Client<livoxmock_i::srv::FilterPointCloud>::SharedPtr clientFilterPointCloud;

	 

};


//SURROGATE_INIT
 



}










 

