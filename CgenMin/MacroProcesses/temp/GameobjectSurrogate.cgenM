##Macro1 
 ##LoopIncrement1 
 ##ToFile C:\Users\SyncthingServiceAcct\QR_Sync\world2\rosqt\include\world2_rqt\GameobjectSurrogate.h 
//############################################### 
//this is an autogenerated file using cgen's macro2 command. Dont modify this file here unless it is in user sections 
//###############################################

#pragma once

//place all headers you need here.
##UserCode_header

#include "qr_core/msg/void_int32_changed.hpp"
#include "qr_core/srv/sync_int32.hpp"






#include "world2_cp/GameobjectBase.h" 



namespace world2_rqt {
using namespace world2_i::msg;
using namespace world2_i::srv;
using namespace world2_cp;
 

//this gets code generated 100% from the previous  cpp object! there is nothing for the user to do here. all public functions will be code generated over to here.
//This is the surrogate object.
 
typedef Ticket<void> SpawnObjectTicket_t; 

 
 
//This class is the surrogate class
class GameobjectSurrogate : public  GameobjectBase 
{
public:

 
    friend void GameobjectInitialized_Callback(const world2_i::msg::GameobjectData msg);

	##UserCode_public

    //This class should not be instantiated by the user. instead the GameobjectInitialized_Callback will handle
	//instantiations of this class.
GameobjectSurrogate(std::string id): GameobjectBase(id)
    {
		##UserCode_constr1
	
        _isReal = false;

		//you need a spinning node. make sure that node is not being used for the same service you are trying to call. currently TheDataAccessManager is being
		//used for clients.   
		
        auto nodeToUse =  TheDataAccessManagerNode;//rclcpp::Node::make_shared(id+"GameobjectSurrogate");;

        //instances of surrogates can be created at any point of the application life cycle! THink aboiut the case
        //here where world2 holds a list of gameobjects. These gameobjects are AO that can be created at any time.


        //scratch the bottom!!! ----------------------------------------------------
        //we are assuming that the instance for this surrogate is created already. we need to grab the data for this surrogate
        //before moving on. The reason we need to wait to grab it is because we are assuming that this application relies on this
        //instance being created already. What this means though is that instances of AO CANNOT be instantiated in midst of the application
        //running. For example within function calls might have  Gameobject* w = new Gameobject();
 

		//=====================================
		//AOFUNCTION_CLIENTS
		//=====================================
		clientSpawnObject = nodeToUse->create_client<world2_i::srv::SpawnObject>(id + "/SpawnObject"); 

		
		 
		##UserCode_constr2
SurrogateDatasyncCallbackGroup = TheDataAccessManagerNode->create_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);		

		//DATASYNC_DEFINE
		clientsetposx = TheDataAccessManagerNode->create_client<qr_core::srv::SyncInt32>(id + "/setposx");
TicketFor_Setposx = nullptr;
posx_datasync = new DataSyncing<int32_t,
qr_core::srv::SyncInt32,
qr_core::msg::VoidInt32Changed>(id, "posx", &(this->data.posx), SurrogateDatasyncCallbackGroup);
clientsetposy = TheDataAccessManagerNode->create_client<qr_core::srv::SyncInt32>(id + "/setposy");
TicketFor_Setposy = nullptr;
posy_datasync = new DataSyncing<int32_t,
qr_core::srv::SyncInt32,
qr_core::msg::VoidInt32Changed>(id, "posy", &(this->data.posy), SurrogateDatasyncCallbackGroup);



    }
 
 public:
 
 	//=====================================
	//AOFUNCTION_IMPS
	//===================================== 
	    //the non-async version will just call the async version but will immediately wait for the ticket.
    void SpawnObject() override
    {
        auto ticket = SpawnObject_async();
        return ticket->AwaitRequestUntilFinished();
    }




    TicketFuture_RosService<std::shared_future<
                                rclcpp::Client<world2_i::srv::SpawnObject>::SharedResponse>,
                            void,
                            world2_i::srv::SpawnObject>* TicketFor_SpawnObject;


    SpawnObjectTicket_t* SpawnObject_async() override
    {
        //in this surrogate, I need to prepare the data for transmission over the network.
        //First I need to package the data into the data interface type for this service function.
        //If one of the arguments for the function is an "AOSurrogate" type, a string Id will be used
        //as a replacement for it. The example for this interface type will be

        //        WorldMoveObject.srv
        //        world2_i::msg::void result
        //        ---
        //        std_msgs::msg::String surrogate
        //        world2_i::msg::Move move

		auto request = std::make_shared<world2_i::srv::SpawnObject::Request>();  
		 //whenever the arguments is a surrogate, it will get the id instead of passing the actual object
        
 



        TicketFor_SpawnObject= new TicketFuture_RosService<std::shared_future<
                                                           rclcpp::Client<world2_i::srv::SpawnObject>::SharedResponse>,
                                                           void,
                                                           world2_i::srv::SpawnObject>();
        auto result =
            clientSpawnObject->async_send_request(request, TicketFor_SpawnObject->CallbackToServiceVar); 

        TicketFor_SpawnObject->SetNewFuture(result.future);

        //create the ticket the user can use to await this request.
        TicketFor_SpawnObject->MutexForTicket.lock();
        return (SpawnObjectTicket_t*)TicketFor_SpawnObject;
    }



 
  
 
	//UPDATE_CALLBACK
	     void UpdateObjCallback(const world2_i::msg::GameobjectData* msg)
    {
        data = *msg;
    }

    void _UpdateObjCallback(const world2_i::msg::GameobjectData::SharedPtr msg)
    {
        UpdateObjCallback(msg.get());
        //        data = *);
    }
	 
	 rclcpp::CallbackGroup::SharedPtr SurrogateDatasyncCallbackGroup;
	 //DATASYNC_DECL
	 DataSyncing<int32_t,
qr_core::srv::SyncInt32,
qr_core::msg::VoidInt32Changed>* posx_datasync;
TicketFuture<std::shared_future<rclcpp::Client<qr_core::srv::SyncInt32>::SharedResponse>, void>* TicketFor_Setposx;rclcpp::Client<qr_core::srv::SyncInt32>::SharedPtr clientsetposx;
DataSyncing<int32_t,
qr_core::srv::SyncInt32,
qr_core::msg::VoidInt32Changed>* posy_datasync;
TicketFuture<std::shared_future<rclcpp::Client<qr_core::srv::SyncInt32>::SharedResponse>, void>* TicketFor_Setposy;rclcpp::Client<qr_core::srv::SyncInt32>::SharedPtr clientsetposy;



	
	//=====================================
	//DATASYNC_IMPS
	//===================================== 
	// 
	void Setposx(int32_t p) override{
        //QR_Print("posx Set() has been entered by surrogate");


        //await the ticket if there was a previously created set requested.
        //this may not actually be needed but is here to assure one-at-a-time requests
        //if(TicketFor_Setposx != nullptr)
        //{
            //TicketFor_Setposx->AwaitRequestUntilFinished();
        //}

        //set a datasync to generate a random session number for this request
        auto syncSession = posx_datasync->GenerateSession();
 
        //QR_Print("starting a setposx request.");
 
        auto request = std::make_shared<qr_core::srv::SyncInt32::Request>();
        request->arg1 = p;
        request->id1 = syncSession->getArg1();
        request->id2 = syncSession->getArg2();

        auto setposx_callback = [&,this](rclcpp::Client<qr_core::srv::SyncInt32>::SharedFuture inner_future ){
            //unlock the ticket's mutex
            //QR_Print("callback for service posx recieved");
            //this->data.posx = inner_future.get()->result;
            //this->TicketFor_Setposx->MutexForTicket.unlock();
        };
        auto result = clientsetposx->async_send_request(request, setposx_callback);



        TicketFor_Setposx = new TicketFuture<std::shared_future<rclcpp::Client<qr_core::srv::SyncInt32>::SharedResponse>, void>(result.future);
        TicketFor_Setposx->MutexForTicket.lock();

        posx_datasync->SetHasBeenRefreshedSinceSet(false);

        //you can now set the actual data update in this surrogate. the publishedchanged event wont effect this
        //surrogate as this is the requesting surrogate
        this->data.posx = p;

        //give this ticket to the data_sync object
        //posx_datasync->TicketForData = TicketFor_Setposx;
 
    }
    int Getposx() const override{
        //Just get the data from the local data as it should always be synced to the real one.
        return this->data.posx;
    }
 
	void Setposy(int32_t p) override{
        //QR_Print("posy Set() has been entered by surrogate");


        //await the ticket if there was a previously created set requested.
        //this may not actually be needed but is here to assure one-at-a-time requests
        //if(TicketFor_Setposy != nullptr)
        //{
            //TicketFor_Setposy->AwaitRequestUntilFinished();
        //}

        //set a datasync to generate a random session number for this request
        auto syncSession = posy_datasync->GenerateSession();
 
        //QR_Print("starting a setposy request.");
 
        auto request = std::make_shared<qr_core::srv::SyncInt32::Request>();
        request->arg1 = p;
        request->id1 = syncSession->getArg1();
        request->id2 = syncSession->getArg2();

        auto setposy_callback = [&,this](rclcpp::Client<qr_core::srv::SyncInt32>::SharedFuture inner_future ){
            //unlock the ticket's mutex
            //QR_Print("callback for service posy recieved");
            //this->data.posy = inner_future.get()->result;
            //this->TicketFor_Setposy->MutexForTicket.unlock();
        };
        auto result = clientsetposy->async_send_request(request, setposy_callback);



        TicketFor_Setposy = new TicketFuture<std::shared_future<rclcpp::Client<qr_core::srv::SyncInt32>::SharedResponse>, void>(result.future);
        TicketFor_Setposy->MutexForTicket.lock();

        posy_datasync->SetHasBeenRefreshedSinceSet(false);

        //you can now set the actual data update in this surrogate. the publishedchanged event wont effect this
        //surrogate as this is the requesting surrogate
        this->data.posy = p;

        //give this ticket to the data_sync object
        //posy_datasync->TicketForData = TicketFor_Setposy;
 
    }
    int Getposy() const override{
        //Just get the data from the local data as it should always be synced to the real one.
        return this->data.posy;
    }

    int Getisstatic() const override{
        //Just get the data from the local data as it should always be synced to the real one.
        return this->data.isstatic;
    }


private:

	##UserCode_priv

	//AOFUNCTION_CLIENT_DECLARES
	rclcpp::Client<world2_i::srv::SpawnObject>::SharedPtr clientSpawnObject;

	 

};


//SURROGATE_INIT
 

//This object will subscribe to an initialization event that all REAL AO objects publish after they are created.
//For example, for this case, a GameobjectAO will publish an InitializedEvent triggered via a one shot timer when the AO spins.
//Then all modules that have a surrogate of this type will get that event and sync GameobjectDataAccess data with it.


class GameobjectInit
{
public:
    rclcpp::Subscription<world2_i::msg::GameobjectData>::SharedPtr subscriptionInitialized;



    void InitializeSurrogates()
    {
#ifdef AllSurrogates
        auto nodeToUse = TheNodeForAllSurrogates;

#else
        auto nodeToUse = TheDataAccessManagerNode;

#endif

        subscriptionInitialized = nodeToUse->create_subscription<world2_i::msg::GameobjectData>
                                  ("/GameobjectInitialized", 10, std::bind(&GameobjectInit::GameobjectInitialized_Callback,this, _1));


        /*    subscriptionInitialized = TheDataAccessManagerNode->create_subscription<world2_i::msg::GameobjectData>
                ("/GameobjectInitialized", 10, &GameobjectInitialized_Callback);*///std::bind(GameobjectInitialized_Callback,_1));//std::bind(&Gameobject::GameobjectInitialized_Callback, this,_1));
    }

private:

    void GameobjectInitialized_Callback(const world2_i::msg::GameobjectData::SharedPtr msg)
    {
        QR_Print("Surrogate created for AO: %s", msg->id.c_str());
        //if this object exists already, just update the data, if it does not exist, create the object
        GameobjectSurrogate* o = (GameobjectSurrogate*)GameobjectSurrogate::GetObjectFromPool(msg->id);
        if (o == nullptr)
        {
            //first create an instance of the surrogate
            GameobjectSurrogate* sur = new GameobjectSurrogate(msg->id);
            sur->_UpdateObjCallback(msg);
            //and that's it actually, the object adds itself to the surrogate object pool.

        }
        else
        {
            o->_UpdateObjCallback(msg);

        }

        //maybe notify this AO that the AO in question has been created?

    }

};



}










 

