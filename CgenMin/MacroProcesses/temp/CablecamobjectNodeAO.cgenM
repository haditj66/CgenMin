##Macro1 
 ##LoopIncrement1 
 ##ToFile C:\Users\SyncthingServiceAcct\QR_Sync\cablecam\rosqt\include\cablecam_rqt\CablecamobjectNodeAO.h 
//############################################### 
//this is an autogenerated file using cgen's macro2 command. Dont modify this file here unless it is in user sections 
//###############################################

#pragma once
 
#include "Config.hpp"

#include "cablecam_cp/Cablecamobject.h"
#include "QR_Core.h" 
  
#include "rclcpp/rclcpp.hpp"
#include "std_msgs/msg/string.hpp"

#include <chrono>
#include <memory>
#include <functional>
#include <string>



//**************************************************************************************************************
//This ABSTRACT class is 100% code generated! users should derive from this class to create their own AO.
//this is the class that will have asychronous calls taken into account. This is what will call the internal
//object.
//This base AO class will be full code generated. However, the class that inherits from this base class will be user created. That class will have
//extra things like timers or subscriptions or etc.


namespace cablecam_rqt {
	using std::placeholders::_1;
	using std::placeholders::_2;
	
using namespace cablecam_i::msg;
using namespace cablecam_i::srv;
using namespace cablecam_cp;

class CablecamobjectNodeAO// : public rclcpp::Node
{
public:



    //std::shared_ptr<WorldNode> fForNode;
    rclcpp::Node*  ForNode;
    cablecam_cp::Cablecamobject* cppobj;

	//this event is published when the node for the real AO is created. All surrogate nodes will be
	// notified by this event. This
    rclcpp::Publisher<cablecam_i::msg::CablecamobjectData>::SharedPtr publisherInitialized;

	//WNFUNCTION_SERVICES
	 
	
	//PROPERTYEVTS_DECLARED
	
 
	//PROPERTYEVTS_CHANGED_DECLARE
	
	//rclcpp::Publisher<qr_core::msg::VoidInt64Changed>::SharedPtr publisherposxChanged;
    //rclcpp::Publisher<qr_core::msg::VoidInt64Changed>::SharedPtr publisherposyChanged;



    //MyNode();
    virtual ~CablecamobjectNodeAO ()
    {
        rclcpp::shutdown();
    }


rclcpp::CallbackGroup::SharedPtr client_cb_group_;



    void Init(cablecam_cp::Cablecamobject* obj)//, rclcpp::executors::MultiThreadedExecutor* exec)
    {
//          fForNode = QR_Core::CreateNode<world2_rqt::WorldNode>(exec, obj->Getid());

//         ForNode = (rclcpp::Node *)fForNode.get();

        this->cppobj = obj;
        std::string n = ForNode->get_name();
        cppobj->Setid(n);

        static const rmw_qos_profile_t rmw_qos_profile_services_default_MINE = {
          RMW_QOS_POLICY_HISTORY_KEEP_LAST,
          1000,
          RMW_QOS_POLICY_RELIABILITY_RELIABLE,
          RMW_QOS_POLICY_DURABILITY_VOLATILE,
          RMW_QOS_DEADLINE_DEFAULT,
          RMW_QOS_LIFESPAN_DEFAULT,
          RMW_QOS_POLICY_LIVELINESS_SYSTEM_DEFAULT,
          RMW_QOS_LIVELINESS_LEASE_DURATION_DEFAULT,
          false};

        client_cb_group_ = ForNode->create_callback_group(
            rclcpp::CallbackGroupType::MutuallyExclusive);
			
			
		//WNFUNCTION_SERVICES_DEFINES	
		



        // I need a publisher to the initialized event. This event will need to be
        // pulished in the initialize function that must be called after this
        // constructor everytime.
        publisherInitialized = ForNode->create_publisher<cablecam_i::msg::CablecamobjectData>(
            "/CablecamobjectInitialized", 100);

        publisherInitialized->publish(cppobj->GetObjectData());
		
		//PROPERTYEVTS_DECLARED
		//since this deals with data access modifying, This will be managed by the DataAccessManagerNode
		
		
 
		
		//PROPERTYEVTS_CHANGED_DEFINE
		
		
		isInitialized = true;
    }

 
 
	//PROPERTYEVTS_SET_CALLBACKS
	

	
 
	//WNFUNCTIONS_IMPL
	

  

protected:

	bool isInitialized;

};
}




