##Macro1 
 ##LoopIncrement1 
 ##ToFile /home/hadi/QR_Sync/voxelgrid/rosqt/include/voxelgrid_rqt/VoxelizerSurrogate.h 
//############################################### 
//this is an autogenerated file using cgen's macro2 command. Dont modify this file here unless it is in user sections 
//###############################################

#pragma once

//place all headers you need here.
##UserCode_header

#include "voxelgrid_i/srv/compute_voxel_statistics.hpp" 




#include "QR_Core.h"





namespace voxelgrid_rqt {
//using namespace voxelgrid_i::msg;
using namespace voxelgrid_i::srv;
//using namespace voxelgrid_cp;
 

//this gets code generated 100% from the previous  cpp object! there is nothing for the user to do here. all public functions will be code generated over to here.
//This is the surrogate object.
 
typedef Ticket<voxelgrid_i::srv::ComputeVoxelStatistics_Response::_result_type> ComputeVoxelStatisticsTicket_t; 

 
 
//This class is the surrogate class
class VoxelizerSurrogate 
{
public:

 
    

	##UserCode_public

    //This class should not be instantiated by the user. instead the VoxelizerInitialized_Callback will handle
	//instantiations of this class.
VoxelizerSurrogate(std::string id)
    {
		##UserCode_constr1
	
        

		//you need a spinning node. make sure that node is not being used for the same service you are trying to call. currently TheDataAccessManager is being
		//used for clients.   
		
        auto nodeToUse =  TheDataAccessManagerNode;//rclcpp::Node::make_shared(id+"VoxelizerSurrogate");;

        //instances of surrogates can be created at any point of the application life cycle! THink aboiut the case
        //here where voxelgrid holds a list of gameobjects. These gameobjects are AO that can be created at any time.


        //scratch the bottom!!! ----------------------------------------------------
        //we are assuming that the instance for this surrogate is created already. we need to grab the data for this surrogate
        //before moving on. The reason we need to wait to grab it is because we are assuming that this application relies on this
        //instance being created already. What this means though is that instances of AO CANNOT be instantiated in midst of the application
        //running. For example within function calls might have  Voxelizer* w = new Voxelizer();
 

		//=====================================
		//AOFUNCTION_CLIENTS
		//=====================================
		clientComputeVoxelStatistics = nodeToUse->create_client<voxelgrid_i::srv::ComputeVoxelStatistics>(id + "/ComputeVoxelStatistics"); 

		
		 
		##UserCode_constr2
SurrogateDatasyncCallbackGroup = TheDataAccessManagerNode->create_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);		

		//DATASYNC_DEFINE
		

    }
 
 public:
 
 	//=====================================
	//AOFUNCTION_IMPS
	//===================================== 
	    //the non-async version will just call the async version but will immediately wait for the ticket.
    voxelgrid_i::msg::VoxelStatistics ComputeVoxelStatistics(int32_t frames_back) 
    {
        auto ticket = ComputeVoxelStatistics_async(frames_back);
        return ticket->AwaitRequestUntilFinished();
    }




    TicketFuture_RosService<std::shared_future<
                                rclcpp::Client<voxelgrid_i::srv::ComputeVoxelStatistics>::SharedResponse>,
                            voxelgrid_i::srv::ComputeVoxelStatistics_Response::_result_type,
                            voxelgrid_i::srv::ComputeVoxelStatistics>* TicketFor_ComputeVoxelStatistics;


    ComputeVoxelStatisticsTicket_t* ComputeVoxelStatistics_async(int32_t frames_back) 
    {
        //in this surrogate, I need to prepare the data for transmission over the network.
        //First I need to package the data into the data interface type for this service function.
        //If one of the arguments for the function is an "AOSurrogate" type, a string Id will be used
        //as a replacement for it. The example for this interface type will be

        //        WorldMoveObject.srv
        //        voxelgrid_i::msg::voxelgrid_i::msg::VoxelStatistics result
        //        ---
        //        std_msgs::msg::String surrogate
        //        voxelgrid_i::msg::Move move

		auto request = std::make_shared<voxelgrid_i::srv::ComputeVoxelStatistics::Request>();  
		 //whenever the arguments is a surrogate, it will get the id instead of passing the actual object
        request->frames_back = frames_back;

 



        TicketFor_ComputeVoxelStatistics= new TicketFuture_RosService<std::shared_future<
                                                           rclcpp::Client<voxelgrid_i::srv::ComputeVoxelStatistics>::SharedResponse>,
                                                           voxelgrid_i::srv::ComputeVoxelStatistics_Response::_result_type,
                                                           voxelgrid_i::srv::ComputeVoxelStatistics>();
        auto result =
            clientComputeVoxelStatistics->async_send_request(request, TicketFor_ComputeVoxelStatistics->CallbackToServiceVar); 

        TicketFor_ComputeVoxelStatistics->SetNewFuture(result.future);

        //create the ticket the user can use to await this request.
        TicketFor_ComputeVoxelStatistics->MutexForTicket.lock();
        return (ComputeVoxelStatisticsTicket_t*)TicketFor_ComputeVoxelStatistics;
    }



 
  
 
	//UPDATE_CALLBACK
	 
	 
	 rclcpp::CallbackGroup::SharedPtr SurrogateDatasyncCallbackGroup;
	 //DATASYNC_DECL
	 

	
	//=====================================
	//DATASYNC_IMPS
	//===================================== 
	//

private:

	##UserCode_priv

	//AOFUNCTION_CLIENT_DECLARES
	rclcpp::Client<voxelgrid_i::srv::ComputeVoxelStatistics>::SharedPtr clientComputeVoxelStatistics;

	 

};


//SURROGATE_INIT
 



}










 

