##Macro1 
 ##LoopIncrement1 
 ##ToFile /home/hadi/QR_Sync/world2/rosqt/include/world2_rqt/WorldSurrogate.h 
//############################################### 
//this is an autogenerated file using cgen's macro2 command. Dont modify this file here unless it is in user sections 
//###############################################

#pragma once

//place all headers you need here.
##UserCode_header

#include "world2_i/msg/test_msg.hpp" 
#include "world2_i/msg/move_response.hpp" 
#include "world2_i/msg/move.hpp" 
#include "world2_i/srv/move_object.hpp" 
#include "world2_i/msg/add_object_response.hpp" 
#include "world2_i/srv/add_object_to_world.hpp" 
#include "world2_i/msg/world_data.hpp" 
#include "world2_i/srv/spawn_object.hpp" 
#include "world2_i/msg/gameobject_data.hpp" 


#include "qr_core/msg/void_int32_changed.hpp"
#include "qr_core/srv/sync_int32.hpp"




#include "world2_cp/WorldBase.h" 



namespace world2_rqt {
using namespace world2_i::msg;
using namespace world2_i::srv;
using namespace world2_cp;
 

//this gets code generated 100% from the previous  cpp object! there is nothing for the user to do here. all public functions will be code generated over to here.
//This is the surrogate object.
 
typedef Ticket<world2_i::srv::MoveObject_Response::_result_type> MoveObjectTicket_t; 
typedef Ticket<world2_i::srv::AddObjectToWorld_Response::_result_type> AddObjectToWorldTicket_t; 

 
 
//This class is the surrogate class
class WorldSurrogate : public  WorldBase 
{
public:

 
    friend void WorldInitialized_Callback(const world2_i::msg::WorldData msg);

	##UserCode_public

    //This class should not be instantiated by the user. instead the WorldInitialized_Callback will handle
	//instantiations of this class.
WorldSurrogate(std::string id): WorldBase(id)
    {
		##UserCode_constr1
	
        _isReal = false;

		//you need a spinning node. make sure that node is not being used for the same service you are trying to call. currently TheDataAccessManager is being
		//used for clients.   
		
        auto nodeToUse =  TheDataAccessManagerNode;//rclcpp::Node::make_shared(id+"WorldSurrogate");;

        //instances of surrogates can be created at any point of the application life cycle! THink aboiut the case
        //here where world2 holds a list of gameobjects. These gameobjects are AO that can be created at any time.


        //scratch the bottom!!! ----------------------------------------------------
        //we are assuming that the instance for this surrogate is created already. we need to grab the data for this surrogate
        //before moving on. The reason we need to wait to grab it is because we are assuming that this application relies on this
        //instance being created already. What this means though is that instances of AO CANNOT be instantiated in midst of the application
        //running. For example within function calls might have  World* w = new World();
 

		//=====================================
		//AOFUNCTION_CLIENTS
		//=====================================
		clientMoveObject = nodeToUse->create_client<world2_i::srv::MoveObject>(id + "/MoveObject"); 
clientAddObjectToWorld = nodeToUse->create_client<world2_i::srv::AddObjectToWorld>(id + "/AddObjectToWorld"); 

		
		 
		##UserCode_constr2
SurrogateDatasyncCallbackGroup = TheDataAccessManagerNode->create_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);		

		//DATASYNC_DEFINE
		


    }
 
 public:
 
 	//=====================================
	//AOFUNCTION_IMPS
	//===================================== 
	    //the non-async version will just call the async version but will immediately wait for the ticket.
    MoveResponse MoveObject(GameobjectBase* AOObj,Move move) override
    {
        auto ticket = MoveObject_async(AOObj, move);
        return ticket->AwaitRequestUntilFinished();
    }




    TicketFuture_RosService<std::shared_future<
                                rclcpp::Client<world2_i::srv::MoveObject>::SharedResponse>,
                            world2_i::srv::MoveObject_Response::_result_type,
                            world2_i::srv::MoveObject>* TicketFor_MoveObject;


    MoveObjectTicket_t* MoveObject_async(GameobjectBase* AOObj,Move move) override
    {
        //in this surrogate, I need to prepare the data for transmission over the network.
        //First I need to package the data into the data interface type for this service function.
        //If one of the arguments for the function is an "AOSurrogate" type, a string Id will be used
        //as a replacement for it. The example for this interface type will be

        //        WorldMoveObject.srv
        //        world2_i::msg::MoveResponse result
        //        ---
        //        std_msgs::msg::String surrogate
        //        world2_i::msg::Move move

		auto request = std::make_shared<world2_i::srv::MoveObject::Request>();  
		 //whenever the arguments is a surrogate, it will get the id instead of passing the actual object
        request->id = AOObj->Getid();

request->move = move;

 



        TicketFor_MoveObject= new TicketFuture_RosService<std::shared_future<
                                                           rclcpp::Client<world2_i::srv::MoveObject>::SharedResponse>,
                                                           world2_i::srv::MoveObject_Response::_result_type,
                                                           world2_i::srv::MoveObject>();
        auto result =
            clientMoveObject->async_send_request(request, TicketFor_MoveObject->CallbackToServiceVar); 

        TicketFor_MoveObject->SetNewFuture(result.future);

        //create the ticket the user can use to await this request.
        TicketFor_MoveObject->MutexForTicket.lock();
        return (MoveObjectTicket_t*)TicketFor_MoveObject;
    }


    //the non-async version will just call the async version but will immediately wait for the ticket.
    AddObjectResponse AddObjectToWorld(GameobjectBase* AOObj,int32_t posy,int32_t posx) override
    {
        auto ticket = AddObjectToWorld_async(AOObj, posy, posx);
        return ticket->AwaitRequestUntilFinished();
    }




    TicketFuture_RosService<std::shared_future<
                                rclcpp::Client<world2_i::srv::AddObjectToWorld>::SharedResponse>,
                            world2_i::srv::AddObjectToWorld_Response::_result_type,
                            world2_i::srv::AddObjectToWorld>* TicketFor_AddObjectToWorld;


    AddObjectToWorldTicket_t* AddObjectToWorld_async(GameobjectBase* AOObj,int32_t posy,int32_t posx) override
    {
        //in this surrogate, I need to prepare the data for transmission over the network.
        //First I need to package the data into the data interface type for this service function.
        //If one of the arguments for the function is an "AOSurrogate" type, a string Id will be used
        //as a replacement for it. The example for this interface type will be

        //        WorldMoveObject.srv
        //        world2_i::msg::AddObjectResponse result
        //        ---
        //        std_msgs::msg::String surrogate
        //        world2_i::msg::Move move

		auto request = std::make_shared<world2_i::srv::AddObjectToWorld::Request>();  
		 //whenever the arguments is a surrogate, it will get the id instead of passing the actual object
        request->id = AOObj->Getid();

request->posy = posy;

request->posx = posx;

 



        TicketFor_AddObjectToWorld= new TicketFuture_RosService<std::shared_future<
                                                           rclcpp::Client<world2_i::srv::AddObjectToWorld>::SharedResponse>,
                                                           world2_i::srv::AddObjectToWorld_Response::_result_type,
                                                           world2_i::srv::AddObjectToWorld>();
        auto result =
            clientAddObjectToWorld->async_send_request(request, TicketFor_AddObjectToWorld->CallbackToServiceVar); 

        TicketFor_AddObjectToWorld->SetNewFuture(result.future);

        //create the ticket the user can use to await this request.
        TicketFor_AddObjectToWorld->MutexForTicket.lock();
        return (AddObjectToWorldTicket_t*)TicketFor_AddObjectToWorld;
    }



 
  
 
	//UPDATE_CALLBACK
	     void UpdateObjCallback(const world2_i::msg::WorldData* msg)
    {
        data = *msg;
    }

    void _UpdateObjCallback(const world2_i::msg::WorldData::SharedPtr msg)
    {
        UpdateObjCallback(msg.get());
        //        data = *);
    }
	 
	 rclcpp::CallbackGroup::SharedPtr SurrogateDatasyncCallbackGroup;
	 //DATASYNC_DECL
	 


	
	//=====================================
	//DATASYNC_IMPS
	//===================================== 
	//
    int Getnumofgameobjects() const override{
        //Just get the data from the local data as it should always be synced to the real one.
        return this->data.numofgameobjects;
    }


private:

	##UserCode_priv

	//AOFUNCTION_CLIENT_DECLARES
	rclcpp::Client<world2_i::srv::MoveObject>::SharedPtr clientMoveObject;
rclcpp::Client<world2_i::srv::AddObjectToWorld>::SharedPtr clientAddObjectToWorld;

	 

};


//SURROGATE_INIT
 

//This object will subscribe to an initialization event that all REAL AO objects publish after they are created.
//For example, for this case, a WorldAO will publish an InitializedEvent triggered via a one shot timer when the AO spins.
//Then all modules that have a surrogate of this type will get that event and sync WorldDataAccess data with it.


class WorldInit
{
public:
    rclcpp::Subscription<world2_i::msg::WorldData>::SharedPtr subscriptionInitialized;



    void InitializeSurrogates()
    {
#ifdef AllSurrogates
        auto nodeToUse = TheNodeForAllSurrogates;

#else
        auto nodeToUse = TheDataAccessManagerNode;

#endif

        subscriptionInitialized = nodeToUse->create_subscription<world2_i::msg::WorldData>
                                  ("/WorldInitialized", 10, std::bind(&WorldInit::WorldInitialized_Callback,this, _1));


        /*    subscriptionInitialized = TheDataAccessManagerNode->create_subscription<world2_i::msg::WorldData>
                ("/WorldInitialized", 10, &WorldInitialized_Callback);*///std::bind(WorldInitialized_Callback,_1));//std::bind(&World::WorldInitialized_Callback, this,_1));
    }

private:

    void WorldInitialized_Callback(const world2_i::msg::WorldData::SharedPtr msg)
    {
        QR_Print("Surrogate created for AO: %s", msg->id.c_str());
        //if this object exists already, just update the data, if it does not exist, create the object
        WorldSurrogate* o = (WorldSurrogate*)WorldSurrogate::GetObjectFromPool(msg->id);
        if (o == nullptr)
        {
            //first create an instance of the surrogate
            WorldSurrogate* sur = new WorldSurrogate(msg->id);
            sur->_UpdateObjCallback(msg);
            //and that's it actually, the object adds itself to the surrogate object pool.

        }
        else
        {
            o->_UpdateObjCallback(msg);

        }

        //maybe notify this AO that the AO in question has been created?

    }

};



}










 

